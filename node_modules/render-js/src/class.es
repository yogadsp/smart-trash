/* eslint-disable import/prefer-default-export */
/* See NOTE-S at the bottom of the file. */
import {access} from './class/access.es';
import {addClass} from './class/addClass.es';
import {addContent} from './class/addContent.es';
import {addStyle} from './class/addStyle.es';
import {build} from './class/build.es';
import {clone} from './class/clone.es';
import {domPath} from './class/domPath.es';
import {element} from './class/element.es';
import {getAttribute} from './class/getAttribute.es';
import {getAttributes} from './class/getAttributes.es';
import {getContent} from './class/getContent.es';
import {getMedia} from './class/getMedia.es';
import {getStyle} from './class/getStyle.es';
import {render} from './class/render.es';
import {setAttribute} from './class/setAttribute.es';
import {setAttributes} from './class/setAttributes.es';
import {setContent} from './class/setContent.es';
import {setMedia} from './class/setMedia.es';
import {setStyle} from './class/setStyle.es';

import {HTML_AND_SVG_ELEMENTS} from './html/elements.es';
import {cdata} from './html/cdata.es';
import {doctype} from './html/doctype.es';

/*
  A little weird way of exporting, but it works when:
  1. imported directly
  2. transpiled to dist
  3. webpacked to lib
*/
exports.access = access;
exports.addClass = addClass;
exports.addContent = addContent;
exports.addStyle = addStyle;
exports.build = build;
exports.clone = clone;
exports.cdata = cdata;
exports.doctype = doctype;
exports.domPath = domPath;
exports.getAttribute = getAttribute;
exports.getAttributes = getAttributes;
exports.getContent = getContent;
exports.getMedia = getMedia;
exports.getStyle = getStyle;
exports.render = render;
exports.setAttribute = setAttribute;
exports.setAttributes = setAttributes;
exports.setContent = setContent;
exports.setMedia = setMedia;
exports.setStyle = setStyle;


HTML_AND_SVG_ELEMENTS.forEach(t => {
  exports[t] = (...args) => element(t, ...args);
}); // forEach

/* NOTE-S

Requirements:

* HTML elements with styling are often reused in lists where only the text changes.
  Rebuilding the same styling over and over seems a waste of CPU cycles.

* Seperating conserns (semantic, styling and content)

* Webcomponents consist of 3 "assets":
  - html
  - css
  - js
  We want to provide all these via a single js function call.
  Where the html is hooked into the browser DOM is currently the developers responsibility.
  CSS should be part of HTML head element.
  Any external css or js will be put in headBegin as link elements.
  Any inlined css will be put in headEnd.
  Inlined JS could be placed pretty much anywhere.

  So with inspiration from Enonic XP pageContributions I think these should suffice for inlined js:
  headEnd
  bodyBegin
  bodyEnd
  preElement (placed in html string on render)
  postElement (placed in html string on render)

Theoretial example:

1. Define semantic (using html element functions, returns a dom object)
2. Apply styling (using objPath API, autogenerated tagName properties)
3. Build (converts style and media to css and class attribute)
4. Clone (use deepmerge)
5. Apply content to clone
6. Render (generates html, css, js?)

Since the objPath API uses HTML tagNames as properties, no object method or
property can have same name as any HTML tagName. Since HTML tagNames can't start
with underscore and underscore singifies something private in JS lets use that
when naming object properties.

Instead of adding a ton of method onto every node in the DOM lets try making
functions that modify the DOM. After all in JS, objects (including arrays) are
passed by reference.

Luckily none of these collide with HTML tagNames:
  * build
  * clone
  * render

Abreviating css class names is nice, but perhaps slow, lets make it optional.

Order of css, especially media queries matter. Lets invent a new media syntax
which handles order.


Allowed html element function syntax:

<nodeFunction> :== tagName([<param>])

<param> :== <spec>? | <content>?

<attributes> ::= null | {property: value}
<content> ::= null | string | <Node> | Array<string|Node>

<media> : == {
  [minWidth: 0]
  [maxWidth: 1920]
  style: {
    property: value,
    '&:hover': {
      property: value
    }
  }
}

Resulting Dom Object:

{
  _t: 'tagName',
  _a: {
    property: value,
    class: ['className'*],
    ...
  },
  _c: <content>,
  _m: <Media>,

  _es: <Ecmascript> // Preferable ECMA-262 5th edition string (so it works in "old" browsers),

  _css: string | Array<string> // Currently CSS3
  _pageContributions: {
    headBegin: Array<string|Node>,
    headEnd: Array<string|Node>,
    bodyBegin: Array<string|Node>,
    bodyEnd: Array<string|Node>,
    preElement: Array<string|Node>, // These could affect css selectors!
    postElement: Array<string|Node>
  }
}

*/
